"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SimpleAuthenticationProvider = void 0;
const HttpClient_1 = __importDefault(require("./HttpClient"));
class SimpleAuthenticationProvider {
    constructor(onCredRequestedImpl) {
        this.onCredRequestedImpl = onCredRequestedImpl;
        this.authToken = '';
    }
    onAuthTokenRequested() {
        return Promise.resolve(this.authToken);
    }
    onCredentialsRequested() {
        return this.onCredRequestedImpl();
    }
    onAuthTokenUpdated(newAuthToken) {
        this.authToken = newAuthToken;
    }
}
exports.SimpleAuthenticationProvider = SimpleAuthenticationProvider;
class ApiManager {
    constructor(baseDomain, authProvider) {
        const self = this;
        const URL = baseDomain + '/api/v2';
        this.http = new HttpClient_1.default(URL, () => {
            return authProvider.onAuthTokenRequested();
        }, () => {
            return Promise.resolve() //
                .then(() => {
                return authProvider.onCredentialsRequested();
            })
                .then((authContent) => {
                return self.login(authContent.password, authContent.otpToken);
            }) //
                .then((authToken) => {
                authProvider.onAuthTokenUpdated(authToken);
            });
        });
    }
    destroy() {
        this.http.destroy();
    }
    login(password, otpToken) {
        const self = this;
        const http = self.http;
        return Promise.resolve() //
            .then((authContent) => {
            return Promise.resolve() //
                .then(http.fetch(http.POST, '/login', {
                password: password,
                otpToken: otpToken,
            }));
        })
            .then(function (data) {
            return data.token;
        });
    }
    getAllThemes() {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.GET, '/user/system/themes/all', {}));
    }
    getCurrentTheme() {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.GET, '/theme/current', {}));
    }
    setCurrentTheme(themeName) {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.POST, '/user/system/themes/setcurrent', {
            themeName,
        }));
    }
    saveTheme(oldName, theme) {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.POST, '/user/system/themes/update', {
            oldName,
            name: theme.name,
            content: theme.content,
        }));
    }
    deleteTheme(themeName) {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.POST, '/user/system/themes/delete', {
            themeName,
        }));
    }
    getProFeaturesState() {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.GET, '/user/pro/state', {}));
    }
    setProApiKey(apiKey) {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.POST, '/user/pro/apikey', { apiKey: apiKey }));
    }
    getProConfigs() {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.GET, '/user/pro/configs', {}));
    }
    setProConfigs(data) {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.POST, '/user/pro/configs', { proConfigs: data }));
    }
    getOtpStatus() {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.GET, '/user/pro/otp', {}));
    }
    setOtpStatus(data) {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.POST, '/user/pro/otp', data));
    }
    getCaptainInfo() {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.GET, '/user/system/info', {}));
    }
    updateRootDomain(rootDomain, force) {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.POST, '/user/system/changerootdomain', {
            rootDomain,
            force,
        }));
    }
    enableRootSsl(emailAddress) {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.POST, '/user/system/enablessl', {
            emailAddress,
        }));
    }
    forceSsl(isEnabled) {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.POST, '/user/system/forcessl', { isEnabled }));
    }
    getAllApps() {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.GET, '/user/apps/appDefinitions', {}));
    }
    getAllProjects() {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.GET, '/user/projects', {}));
    }
    fetchBuildLogs(appName) {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.GET, `/user/apps/appData/${appName}`, {}));
    }
    fetchAppLogsInHex(appName) {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.GET, `/user/apps/appData/${appName}/logs?encoding=hex`, {}));
    }
    uploadAppData(appName, file) {
        const http = this.http;
        let formData = new FormData();
        formData.append('sourceFile', file);
        return Promise.resolve() //
            .then(http.fetch(http.POST, `/user/apps/appData/${appName}?detached=1`, formData));
    }
    registerProject(selectedProject) {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.POST, '/user/projects/register', {
            ...selectedProject,
        }));
    }
    updateProject(project) {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.POST, '/user/projects/update', {
            projectDefinition: project,
        }));
    }
    uploadCaptainDefinitionContent(appName, captainDefinition, gitHash, detached) {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.POST, `/user/apps/appData/${appName}${detached ? '?detached=1' : ''}`, {
            captainDefinitionContent: JSON.stringify(captainDefinition),
            gitHash,
        }));
    }
    updateConfigAndSave(appName, appDefinition) {
        let instanceCount = appDefinition.instanceCount;
        let captainDefinitionRelativeFilePath = appDefinition.captainDefinitionRelativeFilePath;
        let envVars = appDefinition.envVars;
        let notExposeAsWebApp = appDefinition.notExposeAsWebApp;
        let forceSsl = appDefinition.forceSsl;
        let websocketSupport = appDefinition.websocketSupport;
        let volumes = appDefinition.volumes;
        let ports = appDefinition.ports;
        let nodeId = appDefinition.nodeId;
        let appPushWebhook = appDefinition.appPushWebhook;
        let customNginxConfig = appDefinition.customNginxConfig;
        let preDeployFunction = appDefinition.preDeployFunction;
        let serviceUpdateOverride = appDefinition.serviceUpdateOverride;
        let containerHttpPort = appDefinition.containerHttpPort;
        let description = appDefinition.description;
        let httpAuth = appDefinition.httpAuth;
        let appDeployTokenConfig = appDefinition.appDeployTokenConfig;
        let tags = appDefinition.tags;
        let redirectDomain = appDefinition.redirectDomain;
        let projectId = appDefinition.projectId;
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.POST, '/user/apps/appDefinitions/update', {
            appName: appName,
            instanceCount: instanceCount,
            captainDefinitionRelativeFilePath: captainDefinitionRelativeFilePath,
            notExposeAsWebApp: notExposeAsWebApp,
            forceSsl: forceSsl,
            websocketSupport: websocketSupport,
            volumes: volumes,
            ports: ports,
            customNginxConfig: customNginxConfig,
            appPushWebhook: appPushWebhook,
            nodeId: nodeId,
            preDeployFunction: preDeployFunction,
            serviceUpdateOverride: serviceUpdateOverride,
            containerHttpPort: containerHttpPort,
            description: description,
            httpAuth: httpAuth,
            envVars: envVars,
            appDeployTokenConfig: appDeployTokenConfig,
            tags: tags,
            redirectDomain: redirectDomain,
            projectId: projectId,
        }));
    }
    renameApp(oldAppName, newAppName) {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.POST, '/user/apps/appDefinitions/rename', {
            oldAppName,
            newAppName,
        }));
    }
    registerNewApp(appName, projectId, hasPersistentData, detached) {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.POST, `/user/apps/appDefinitions/register${detached ? '?detached=1' : ''}`, {
            appName,
            projectId,
            hasPersistentData,
        }));
    }
    deleteApp(appName, volumes, appNames) {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.POST, '/user/apps/appDefinitions/delete', {
            appName,
            volumes,
            appNames,
        }));
    }
    deleteProjects(projectIds) {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.POST, '/user/projects/delete', {
            projectIds,
        }));
    }
    enableSslForBaseDomain(appName) {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.POST, '/user/apps/appDefinitions/enablebasedomainssl', {
            appName,
        }));
    }
    attachNewCustomDomainToApp(appName, customDomain) {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.POST, '/user/apps/appDefinitions/customdomain', {
            appName,
            customDomain,
        }));
    }
    enableSslForCustomDomain(appName, customDomain) {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.POST, '/user/apps/appDefinitions/enablecustomdomainssl', {
            appName,
            customDomain,
        }));
    }
    removeCustomDomain(appName, customDomain) {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.POST, '/user/apps/appDefinitions/removecustomdomain', {
            appName,
            customDomain,
        }));
    }
    getLoadBalancerInfo() {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.GET, '/user/system/loadbalancerinfo', {}));
    }
    getNetDataInfo() {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.GET, '/user/system/netdata', {}));
    }
    updateNetDataInfo(netDataInfo) {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.POST, '/user/system/netdata', { netDataInfo }));
    }
    getGoAccessInfo() {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.GET, '/user/system/goaccess', {}));
    }
    updateGoAccessInfo(goAccessInfo) {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.POST, '/user/system/goaccess', { goAccessInfo }));
    }
    getGoAccessReports(appName) {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.GET, `/user/system/goaccess/${appName}/files`, {}));
    }
    getGoAccessReport(reportUrl) {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.GET, reportUrl, {}));
    }
    changePass(oldPassword, newPassword) {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.POST, '/user/changepassword', {
            oldPassword,
            newPassword,
        }));
    }
    getVersionInfo() {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.GET, '/user/system/versioninfo', {}));
    }
    createBackup() {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.POST, '/user/system/createbackup', {
            postDownloadFileName: 'backup.tar',
        }));
    }
    performUpdate(latestVersion) {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.POST, '/user/system/versioninfo', {
            latestVersion,
        }));
    }
    getNginxConfig() {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.GET, '/user/system/nginxconfig', {}));
    }
    setNginxConfig(customBase, customCaptain) {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.POST, '/user/system/nginxconfig', {
            baseConfig: { customValue: customBase },
            captainConfig: { customValue: customCaptain },
        }));
    }
    getUnusedImages(mostRecentLimit) {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.GET, '/user/apps/appDefinitions/unusedImages', {
            mostRecentLimit: mostRecentLimit + '',
        }));
    }
    deleteImages(imageIds) {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.POST, '/user/apps/appDefinitions/deleteImages', {
            imageIds,
        }));
    }
    getDiskCleanUpSettings() {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.GET, '/user/system/diskcleanup', {}));
    }
    setDiskCleanUpSettings(mostRecentLimit, cronSchedule, timezone) {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.POST, '/user/system/diskcleanup', {
            mostRecentLimit,
            cronSchedule,
            timezone,
        }));
    }
    getDockerRegistries() {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.GET, '/user/registries', {}));
    }
    enableSelfHostedDockerRegistry() {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.POST, '/user/system/selfhostregistry/enableregistry', {}));
    }
    disableSelfHostedDockerRegistry() {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.POST, '/user/system/selfhostregistry/disableregistry', {}));
    }
    addDockerRegistry(dockerRegistry) {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.POST, '/user/registries/insert', {
            ...dockerRegistry,
        }));
    }
    updateDockerRegistry(dockerRegistry) {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.POST, '/user/registries/update', {
            ...dockerRegistry,
        }));
    }
    deleteDockerRegistry(registryId) {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.POST, '/user/registries/delete', {
            registryId,
        }));
    }
    setDefaultPushDockerRegistry(registryId) {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.POST, '/user/registries/setpush', {
            registryId,
        }));
    }
    forceBuild(webhookPath) {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.POST, webhookPath, {}));
    }
    getAllNodes() {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.GET, '/user/system/nodes', {}));
    }
    getAllOneClickApps() {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.GET, '/user/oneclick/template/list', {}));
    }
    getOneClickAppByName(appName, baseDomain) {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.GET, '/user/oneclick/template/app', {
            appName,
            baseDomain,
        }));
    }
    getAllOneClickAppRepos() {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.GET, '/user/oneclick/repositories', {}));
    }
    addNewCustomOneClickRepo(repositoryUrl) {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.POST, '/user/oneclick/repositories/insert', {
            repositoryUrl,
        }));
    }
    deleteCustomOneClickRepo(repositoryUrl) {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.POST, '/user/oneclick/repositories/delete', {
            repositoryUrl,
        }));
    }
    addDockerNode(nodeType, privateKey, remoteNodeIpAddress, sshPort, sshUser, captainIpAddress) {
        const http = this.http;
        return Promise.resolve() //
            .then(http.fetch(http.POST, '/user/system/nodes', {
            nodeType,
            privateKey,
            remoteNodeIpAddress,
            sshPort,
            sshUser,
            captainIpAddress,
        }));
    }
}
exports.default = ApiManager;
